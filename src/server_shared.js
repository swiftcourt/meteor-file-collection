// Generated by CoffeeScript 1.12.7
var through2;

import share from './share.js';

if (Meteor.isServer) {
  through2 = Npm.require('through2');
  share.defaultResponseHeaders = {
    'Content-Type': 'text/plain'
  };
  share.check_allow_deny = function(type, userId, file, fields) {
    var checkRules, result;
    checkRules = function(rules) {
      var func, i, len, ref, res;
      res = false;
      ref = rules[type];
      for (i = 0, len = ref.length; i < len; i++) {
        func = ref[i];
        if (!res) {
          res = func(userId, file, fields);
        }
      }
      return res;
    };
    result = !checkRules(this.denys) && checkRules(this.allows);
    return result;
  };
  share.bind_env = function(func) {
    if (func != null) {
      return Meteor.bindEnvironment(func, function(err) {
        throw err;
      });
    } else {
      return func;
    }
  };
  share.safeObjectID = function(s) {
    if (s != null ? s.match(/^[0-9a-f]{24}$/i) : void 0) {
      return new Mongo.ObjectID(s);
    } else {
      return null;
    }
  };
  share.streamChunker = function(size) {
    var makeFuncs;
    if (size == null) {
      size = share.defaultChunkSize;
    }
    makeFuncs = function(size) {
      var bufferList, flush, total, transform;
      bufferList = [new Buffer(0)];
      total = 0;
      flush = function(cb) {
        var lastBuffer, newBuffer, outSize, outputBuffer;
        outSize = total > size ? size : total;
        if (outSize > 0) {
          outputBuffer = Buffer.concat(bufferList, outSize);
          this.push(outputBuffer);
          total -= outSize;
        }
        lastBuffer = bufferList.pop();
        newBuffer = lastBuffer.slice(lastBuffer.length - total);
        bufferList = [newBuffer];
        if (total < size) {
          return cb();
        } else {
          return flush.bind(this)(cb);
        }
      };
      transform = function(chunk, enc, cb) {
        bufferList.push(chunk);
        total += chunk.length;
        if (total < size) {
          return cb();
        } else {
          return flush.bind(this)(cb);
        }
      };
      return [transform, flush];
    };
    return through2.apply(this, makeFuncs(size));
  };
}
